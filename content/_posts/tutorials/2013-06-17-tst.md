---
layout: tutorial
section: dev
active: tutorials
name: TSmarT
description: Try NFC and Zigbee with the TSmarT line of hardware from TST
categories: ["dev", "tutorials"]
tags: ["hardware"]
image: tutorials/tst/familia_TST.jpg

sidebar:
  - link: introduction
    label: Introduction
  - link: setup
    label: Setup
  - link: components
    label: Components
  - link:  example
    label: Try an example
  - link: code
    label: Understanding the code
  - link: finish
    label: Compile & Run
  - link: run
    label: Take this code and run!

---

<!-- Section beginning -->
<div id="introduction" class="tutorial-section">
{% capture section %}
<!-- /Section beginning -->

# Introduction

TSmarT is a modular IoT/M2M wireless communications platform designed to facilitate the development and implementation of smart monitoring and remote control applications in different markets. The TSmarT family encompasses two programmable devices (TSmoTe and TSgaTe) and a growing set of expansion modules to provide access to different technologies (ZigBee, Wi-Fi, Ethernet, GPRS, NFC/RFID, GPS, Modbus, RS-232, RS-485, etc).

These products address OEMs, engineering companies, system integrators or students seeking a simple way to integrate wireless technologies into their products, or have a powerful prototype. A summary of the technical features of the TSmarT platform:

Standard ANSI C programming over proprietary API.
Available communication interfaces: IEEE 802.15.4, ZigBee, DigiMesh, TinyMesh, Wi-Fi, GPRS and Ethernet.
Available expansion modules: RFID, NFC, GPS, RS-232, RS-485, Industrial Sensor adaptor boards.
Embedded software: real-time multitasking operating system FreeRTOS including TCP/IP, HTTP and Modbus stacks.
Toolchain based on free and open source tools (Eclipse and GCC/GDB mainly).
Powerful low-energy 32 bits microcontroller with a powerful ARM Cortex-M3 core.
Large amount of Flash and RAM for these kind of applications.
Other standard interfaces: UART, I2C, SPI, analog and digital I/Os, USB.

## Specs Overview: TSmoTe (Wireless)

| Microcontroller | 32 bit ARM Cortex-M3 
| Clock Speed | 72 MHz
| Flash | 1 MB
| RAM | 96 KB
| Peripherals | microSD cards up to 2 TB, gateway expansion slot (see Introduction)
| Interfaces | 3 UART, 2 I2C, 1 SPI
| Digital I/O Pins | 6 analog, 20 digital

<img src="{% asset_path tutorials/tst/TSmoTe.jpg %}">

## Specs Overview: TSgaTe (Ethernet Gateway)

| Microcontroller | 32 bit ARM Cortex-M3 
| Clock Speed | 72 MHz
| Flash | 256 KB
| RAM | 64 KB
| Peripherals | microSD cards up to 2 TB, gateway expansion slot (see Introduction)
| Interfaces | 3 UART, 2 I2C, 1 SPI
| Digital I/O Pins |   Up to 5 analog, up to 41 digital

<img src="{% asset_path tutorials/tst/TSgaTe.jpg %}">

<!-- Section end -->
{% endcapture %}
{{ section | unindent | markdownify }}
</div>
<!-- /Section end -->


<!-- Section beginning -->
<div id="setup" class="tutorial-section">
{% capture section %}
<!-- /Section beginning -->

# Setting up your TSmarT SDK

If you have already used the TSmarT SDK, you can skip right ahead to the [Components](#components) section. But if you are using your TSmarT platform for the first time, it is advised to read the following steps explaining how to get the board up and running.

The TSmarT SDK consists of several open source software tools grouped in a single integrated development environment (IDE). Working with this environment, users can manage all the processes to program, compile and load their applications to the selected target board (TSgaTe or TSmoTe).

The IDE is composed of several software tools. The main interface is Eclipse, a well known programming IDE. It is customized for programming TSmarT devices by adding GDB as a debugger and OpenOCD to establish the link with the hardware device (via a JTAG connection).

The TST team has developed an installer to install the TSmarT environment in a simple way. It's available [here](http://api.tst-sistemas.es/index.html). Once users have downloaded the intaller, they only have to follow the steps [here](http://api.tst-sistemas.es/quick_start.html). 

To understand this environment better, TST recommend that you read the available documentation on the TST [website](http://www.tst-sistemas.es/Docs/TSmarT_manual.pdf).

TST has also developed [video tutorials](http://api.tst-sistemas.es/docucenter.html) to learn more about how the TSmarT environment works.

<!-- Section end -->
{% endcapture %}
{{ section | unindent | markdownify }}
</div>
<!-- /Section end -->


<!-- Section beginning -->
<div id="components" class="tutorial-section">
{% capture section %}
<!-- /Section beginning -->

#Components

To complete this tutorial, you’ll need the following components:

| 1 x TSmoTe board
| 1 x NFC expansion board
| 1 x Wifi expansion board
| 2 x XBee Digimesh + X-CTU serial program
| 1 x JTAG programmer/debugger
| 1 x USB power supplies 5V / 1A

<!-- Section end -->
{% endcapture %}
{{ section | unindent | markdownify }}
</div>
<!-- /Section end -->


<!-- Section beginning -->
<div id="example" class="tutorial-section">
{% capture section %}
<!-- /Section beginning -->

# Try an example

It's time to try an example. You can find a lot of examples on the differents add-ons to the TSmarT family (UART, GPIO, I2C, SPI...) in the tsmart_examples folder located in the TSmarT root folder. In addition, the TST team has developed an API to work with Xively from all TSmarT devices out of the box. The available API is documented [on TST's website.](http://api.tst-sistemas.es/group___t_s_m_a_r_t___x_v.html) 

<img src="{% asset_path tutorials/tst/demo.jpg %}">

Xively and TST have developed an example to show how to integrate Xively with TSmarT and vice versa. This example creates a new product and a new device on Xively. In addition, the example sends Xively the ID of an NFC (Near-field communication) card detected by an NFC reader, and the data received from a remote XBee.

## X-CTU serial program

This example requires a serial program to manage the remote XBee Digimesh. So the following steps are required:

1. Connect one of the XBees (this XBee will be our remote XBee) to the PC by USB, using an adapter board for XBee.

2. Open your X-CTU serial program. If you don't have the X-CTU program you can download it from the Digi website [here](http://www.digi.com/support/productdetail?pid=3352&osvid=57&type=utilities). (Using the latest firmware is advisable).

3. Set only the PAN ID, operating channel and the destination address (low and high parts) with the following values:

  | Operating channel. i.e.: 0x0E
  | PAN id. i.e.: 0x3322
  | Destination address high
  | Destination address low
  | The rest values shall be default values

  <img src="{% asset_path tutorials/tst/x-ctu_settings.png %}">

<!-- Section end -->
{% endcapture %}
{{ section | unindent | markdownify }}
</div>
<!-- /Section end -->




<!-- Section beginning -->
<div id="code" class="tutorial-section">
{% capture section %}
<!-- /Section beginning -->

# Understanding the code

The code of this example is available in the /tsmart_examples/xively/xv_nfc_wifi_xbee of your TSmarT root folder and is only enabled to work with the TSmoTe board.

If you take a look at this example, you can differentiate 3 parts to the code:

**ONE) init() function** 

This function initializes the hardware and software resources for the application. In this function, the example shall initialize the WiFi interface for Xively connections, the NFC reader, the XBee device (using Digimesh protocol), mutex to synchronize tasks, and the tasks themselves.

<script src="https://gist.github.com/tsttst01/5683566.js"></script>

**TWO) Configuration**

To run this example, it's necessary to set some parameters:

Wireless network parameters:

- SSID. Service Set IDentifier. It is also the network name
- Network key. WiFi network key
- Type of network key: open, WEP, WPA, WPA2
- Local IP. Set 0.0.0.0 for dynamic IP address
- Subnet mask. Set 0.0.0.0 for dynamic IP address
- IP gateway. Set 0.0.0.0 for dynamic IP address
- DNS. Set 0.0.0.0 for dynamic IP address

Digimesh network

- Operating channel. i.e.: 0x0E
- PAN id. i.e.: 0x3322
- Destiantion address high
- Destination address low
- The rest values shall be default values

Xively

- Xively API-KEY: A Xively API key.

Set your configuration in the code below:

<script src="https://gist.github.com/tsttst01/5683542.js"></script>

**THREE) Application tasks**

The example consists of three tasks:

1. **XV task**. This is the main task, because it configures the WiFi communication interface, the NFC reader and the XBee device. In addition, it creates a new product on Xively, and registers a new device under that product.  The device has two datastreams: Id_NFC_Card (the NFC card identifier), and XBee_Data (user-generated data sent using the remote XBee).

2. **XV_NFC task**. This task is constantly checking for the presence of an NFC card. If an NFC card is detected by the NFC reader, its ID card will be sent to Xively.

3. **XV_XBee task**. This task is waiting for new data from the remote XBee. When new data are received, it sends the data to Xively. In addition, this task sends a confirmation message to the remote XBee.

<!-- Section end -->
{% endcapture %}
{{ section | unindent | markdownify }}
</div>
<!-- /Section end -->


<!-- Section beginning -->
<div id="finish" class="tutorial-section">
{% capture section %}
<!-- /Section beginning -->

# Compile, Run and Explore

## Compiling and flashing

To run the example in the TSmoTe board, a binary file is required. This binary file is created by cross compilation. To do the cross compilation, users only need to select the application folder and click the hammer button of the Eclipse interface. After doing the cross compilation process the binary file will be uploaded on to the flash memory of our TSmoTe. Be sure that the TSmoTe board is connected to a power supply, and the JTAG debugger from the PC.

The complete process is described in the following links:

- [One](http://api.tst-sistemas.es/quick_start.html#sec3)
- [Two](http://api.tst-sistemas.es/quick_start.html#sec4)
- [Three](http://api.tst-sistemas.es/docucenter.html)

## Running the example

Once the binary file is allocated in the flash memory, you only have to press the play button.  A hardware reset is accomplished by pressing the reset button on the TSmoTe board.

The example starts with the init function, which handles all initialization. After that, the task will be executed but the XBee and NFC task will be blocked waiting for the start condition that the XV task will send when finished of configuring the devices, connecting with the AP and creating a new product and a new device in Xively. It takes around 20 seconds for the XBee and NFC tasks to begin, depending on your WiFi network. After that the board will sends three messages to the remote XBee:

- "NFC OK"
- "XBee OK"
- "Enter data and press "enter" to send(max. 80 bytes):"

You can see these messages in the terminal tab of your X-CTU serial program. Once you see them, the system is ready to send information to Xively.

<img src="{% asset_path tutorials/tst/x-ctu_ok.png %}">

If you type something in the terminal tab, the data will be sent to Xively to the "XBee_Data" datastream. Additionally, you can check the confirmation message in your X-CTU terminal tab for the message: "Your data was sent to Xively."

<img src="{% asset_path tutorials/tst/x-ctu_sent.png %}">

You can try to use the NFC reader. When an NFC card is detected by the NFC reader, its ID card will be sent to Xively to the "Id_NFC_Card" datastream.

<img src="{% asset_path tutorials/tst/xv_data.png %}">


<!-- Section end -->
{% endcapture %}
{{ section | unindent | markdownify }}
</div>
<!-- /Section end -->




<!-- Section beginning -->
<div id="run" class="tutorial-section">
{% capture section %}
<!-- /Section beginning -->

# Take this code and run!

This example code shows you the basics of how to send data from the TSmarT platforms to Xively using our ANSI C libraries. From here, the opportunities are endless. Give these ideas a try:

* Hook up some real sensors to the TSmarT’s GPIO pins or buses (UART, I2C, SPI), and push this data to Xively.

* Use your TSmarT to subscribe to an existing device over TCP/IP using the different interfaces (ethernet, wifi or GPRS), and have it control or activate things in response to changes in that device.


<!-- Section end -->
{% endcapture %}
{{ section | unindent | markdownify }}
</div>
<!-- /Section end -->